{"version":3,"sources":["webpack:///./node_modules/d3-dsv/src/dsv.js","webpack:///./node_modules/d3-dsv/src/csv.js","webpack:///./node_modules/d3-dsv/src/tsv.js","webpack:///./node_modules/d3-dsv/src/index.js"],"names":["EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","inferColumns","rows","columnSet","Object","create","forEach","row","column","push","pad","value","width","s","length","Array","formatDate","date","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","isNaN","formatYear","year","getUTCFullYear","getUTCMonth","getUTCDate","dsv","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","parseRows","text","f","t","N","I","n","eof","eol","token","c","j","slice","replace","preformatBody","formatValue","formatRow","Date","test","parse","convert","customConverter","object","format","concat","formatBody","formatRows","csv","csvParse","tsv","tsvParse","__webpack_require__","d","__webpack_exports__"],"mappings":"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","file":"npm.d3-dsv-12f15d1a9f4b4db1bf58.js","sourcesContent":["var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nfunction pad(value, width) {\n  var s = value + \"\", length = s.length;\n  return length < width ? new Array(width - length + 1).join(0) + s : s;\n}\n\nfunction formatYear(year) {\n  return year < 0 ? \"-\" + pad(-year, 6)\n    : year > 9999 ? \"+\" + pad(year, 6)\n    : pad(year, 4);\n}\n\nfunction formatDate(date) {\n  var hours = date.getUTCHours(),\n      minutes = date.getUTCMinutes(),\n      seconds = date.getUTCSeconds(),\n      milliseconds = date.getUTCMilliseconds();\n  return isNaN(date) ? \"Invalid Date\"\n      : formatYear(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n      + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n      : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n      : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n      : \"\");\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function preformatBody(rows, columns) {\n    return rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    });\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n  }\n\n  function formatBody(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return preformatBody(rows, columns).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(value) {\n    return value == null ? \"\"\n        : value instanceof Date ? formatDate(value)\n        : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : value;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatBody: formatBody,\n    formatRows: formatRows\n  };\n}\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatBody = csv.formatBody;\nexport var csvFormatRows = csv.formatRows;\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatBody = tsv.formatBody;\nexport var tsvFormatRows = tsv.formatRows;\n","export {default as dsvFormat} from \"./dsv\";\nexport {csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows} from \"./csv\";\nexport {tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows} from \"./tsv\";\nexport {default as autoType} from \"./autoType\";\n"],"sourceRoot":""}