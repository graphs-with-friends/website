{"version":3,"sources":["webpack:///./node_modules/d3-geo/src/adder.js","webpack:///./node_modules/d3-geo/src/math.js","webpack:///./node_modules/d3-geo/src/noop.js","webpack:///./node_modules/d3-geo/src/area.js","webpack:///./node_modules/d3-geo/src/cartesian.js","webpack:///./node_modules/d3-geo/src/bounds.js","webpack:///./node_modules/d3-geo/src/rotation.js","webpack:///./node_modules/d3-geo/src/circle.js","webpack:///./node_modules/d3-geo/src/clip/buffer.js","webpack:///./node_modules/d3-geo/src/pointEqual.js","webpack:///./node_modules/d3-geo/src/clip/rejoin.js","webpack:///./node_modules/d3-geo/src/polygonContains.js","webpack:///./node_modules/d3-geo/src/clip/index.js","webpack:///./node_modules/d3-geo/src/clip/antimeridian.js","webpack:///./node_modules/d3-geo/src/length.js","webpack:///./node_modules/d3-geo/src/path/area.js","webpack:///./node_modules/d3-geo/src/path/context.js","webpack:///./node_modules/d3-geo/src/path/measure.js","webpack:///./node_modules/d3-geo/src/path/string.js","webpack:///./node_modules/d3-geo/src/transform.js","webpack:///./node_modules/d3-geo/src/projection/resample.js","webpack:///./node_modules/d3-geo/src/projection/index.js","webpack:///./node_modules/d3-geo/src/projection/azimuthal.js","webpack:///./node_modules/d3-geo/src/projection/azimuthalEqualArea.js","webpack:///./node_modules/d3-geo/src/projection/azimuthalEquidistant.js","webpack:///./node_modules/d3-geo/src/projection/mercator.js","webpack:///./node_modules/d3-geo/src/projection/equirectangular.js","webpack:///./node_modules/d3-geo/src/projection/conicEquidistant.js","webpack:///./node_modules/d3-geo/src/projection/equalEarth.js","webpack:///./node_modules/d3-geo/src/projection/gnomonic.js","webpack:///./node_modules/d3-geo/src/projection/naturalEarth1.js","webpack:///./node_modules/d3-geo/src/projection/orthographic.js","webpack:///./node_modules/d3-geo/src/projection/stereographic.js","webpack:///./node_modules/d3-geo/src/projection/transverseMercator.js"],"names":["adder","Adder","this","reset","prototype","constructor","s","t","add","y","temp","valueOf","a","b","x","bv","av","epsilon","epsilon2","pi","Math","PI","halfPi","quarterPi","tau","radians","abs","atan","atan2","cos","exp","ceil","log","floor","sin","pow","math_sign","sign","sqrt","tan","acos","asin","noop","cartesian_cartesian","spherical","lambda","phi","cosPhi","cartesianCross","cartesianNormalizeInPlace","d","l","rotationIdentity","round","invert","buffer","line","lines","point","push","lineStart","lineEnd","rejoin","length","pop","concat","shift","result","pointEqual","Intersection","points","other","entry","z","o","e","v","n","p","segments","compareIntersection","startInside","interpolate","stream","i","subject","clip","forEach","segment","p0","p1","sort","rejoin_link","start","current","isSubject","array","sum","longitude","polygonContains","polygon","sinPhi","normal","angle","winding","m","ring","point0","lambda0","phi0","sinPhi0","cosPhi0","j","lambda1","sinPhi1","cosPhi1","point1","phi1","delta","absDelta","antimeridian","k","arc","intersection","phiArc","src_clip","pointVisible","clipLine","sink","ringBuffer","ringSink","polygonStarted","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","Object","src","clip_compareIntersection","sphere","pointLine","clean","ringSegments","filter","validSegment","clipAntimeridianLine","NaN","sign0","sign1","clipAntimeridianIntersect","sinLambda0Lambda1","clipAntimeridianInterpolate","from","to","direction","PathContext","context","_context","_radius","pointRadius","_","_line","_point","closePath","moveTo","lineTo","PathString","_string","string_circle","radius","_circle","join","transformer","methods","TransformStream","key","azimuthalRaw","scale","cx","cy","azimuthalInvert","c","sc","cc","azimuthalEqualAreaRaw","cxcy","azimuthalEquidistantRaw","mercatorRaw","equirectangularRaw","A1","A2","A3","A4","M","equalEarthRaw","l2","l6","gnomonicRaw","naturalEarth1Raw","phi2","phi4","orthographicRaw","stereographicRaw","transverseMercatorRaw"],"mappings":"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","file":"npm.d3-geo-835a221815844bbaf66c.js","sourcesContent":["// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nexport default function() {\n  return new Adder;\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add(temp, y, this.t);\n    add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n","export var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var tau = pi * 2;\n\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\n\nexport var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var ceil = Math.ceil;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var log = Math.log;\nexport var pow = Math.pow;\nexport var sin = Math.sin;\nexport var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nexport var sqrt = Math.sqrt;\nexport var tan = Math.tan;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nexport function haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n","export default function noop() {}\n","import adder from \"./adder\";\nimport {atan2, cos, quarterPi, radians, sin, tau} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nexport var areaRingSum = adder();\n\nvar areaSum = adder(),\n    lambda00,\n    phi00,\n    lambda0,\n    cosPhi0,\n    sinPhi0;\n\nexport var areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnoli’s\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nexport default function(object) {\n  areaSum.reset();\n  stream(object, areaStream);\n  return areaSum * 2;\n}\n","import {asin, atan2, cos, sin, sqrt} from \"./math\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n","import adder from \"./adder\";\nimport {areaStream, areaRingSum} from \"./area\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport {abs, degrees, epsilon, radians} from \"./math\";\nimport stream from \"./stream\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n","import compose from \"./compose\";\nimport {abs, asin, atan2, cos, degrees, pi, radians, sin, tau} from \"./math\";\n\nfunction rotationIdentity(lambda, phi) {\n  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nexport function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nexport default function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n","import {cartesian, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport constant from \"./constant\";\nimport {acos, cos, degrees, epsilon, radians, sin, tau} from \"./math\";\nimport {rotateRadians} from \"./rotation\";\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nexport default function() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n","import noop from \"../noop\";\n\nexport default function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n","import {abs, epsilon} from \"./math\";\n\nexport default function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n","import pointEqual from \"../pointEqual\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n","import adder from \"./adder\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace} from \"./cartesian\";\nimport {abs, asin, atan2, cos, epsilon, halfPi, pi, quarterPi, sign, sin, tau} from \"./math\";\n\nvar sum = adder();\n\nfunction longitude(point) {\n  if (abs(point[0]) <= pi)\n    return point[0];\n  else\n    return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);\n}\n\nexport default function(polygon, point) {\n  var lambda = longitude(point),\n      phi = point[1],\n      sinPhi = sin(phi),\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum.reset();\n\n  if (sinPhi === 1) phi = halfPi + epsilon;\n  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = longitude(point0),\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = longitude(point1),\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n}\n","import clipBuffer from \"./buffer\";\nimport clipRejoin from \"./rejoin\";\nimport {epsilon, halfPi} from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n","import clip from \"./index\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n","import adder from \"./adder\";\nimport {abs, atan2, cos, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar lengthSum = adder(),\n    lambda0,\n    sinPhi0,\n    cosPhi0;\n\nvar lengthStream = {\n  sphere: noop,\n  point: noop,\n  lineStart: lengthLineStart,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, sinPhi0 = sin(phi), cosPhi0 = cos(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin(phi),\n      cosPhi = cos(phi),\n      delta = abs(lambda - lambda0),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,\n      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;\n}\n\nexport default function(object) {\n  lengthSum.reset();\n  stream(object, lengthStream);\n  return +lengthSum;\n}\n","import adder from \"../adder\";\nimport {abs} from \"../math\";\nimport noop from \"../noop\";\n\nvar areaSum = adder(),\n    areaRingSum = adder(),\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;\n    areaSum.add(abs(areaRingSum));\n    areaRingSum.reset();\n  },\n  result: function() {\n    var area = areaSum / 2;\n    areaSum.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaPointFirst(x, y) {\n  areaStream.point = areaPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction areaPoint(x, y) {\n  areaRingSum.add(y0 * x - x0 * y);\n  x0 = x, y0 = y;\n}\n\nfunction areaRingEnd() {\n  areaPoint(x00, y00);\n}\n\nexport default areaStream;\n","import {tau} from \"../math\";\nimport noop from \"../noop\";\n\nexport default function PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n","import adder from \"../adder\";\nimport {sqrt} from \"../math\";\nimport noop from \"../noop\";\n\nvar lengthSum = adder(),\n    lengthRing,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar lengthStream = {\n  point: noop,\n  lineStart: function() {\n    lengthStream.point = lengthPointFirst;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint(x00, y00);\n    lengthStream.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum;\n    lengthSum.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst(x, y) {\n  lengthStream.point = lengthPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction lengthPoint(x, y) {\n  x0 -= x, y0 -= y;\n  lengthSum.add(sqrt(x0 * x0 + y0 * y0));\n  x0 = x, y0 = y;\n}\n\nexport default lengthStream;\n","export default function PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n","export default function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nexport function transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n","import {cartesian} from \"../cartesian\";\nimport {abs, asin, atan2, cos, epsilon, radians, sqrt} from \"../math\";\nimport {transformer} from \"../transform\";\n\nvar maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nexport default function(project, delta2) {\n  return +delta2 ? resample(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n","import clipAntimeridian from \"../clip/antimeridian\";\nimport clipCircle from \"../clip/circle\";\nimport clipRectangle from \"../clip/rectangle\";\nimport compose from \"../compose\";\nimport identity from \"../identity\";\nimport {cos, degrees, radians, sin, sqrt} from \"../math\";\nimport {rotateRadians} from \"../rotation\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\nimport resample from \"./resample\";\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy) {\n  function transform(x, y) {\n    return [dx + k * x, dy - k * y];\n  }\n  transform.invert = function(x, y) {\n    return [(x - dx) / k, (dy - y) / k];\n  };\n  return transform;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, alpha) {\n  var cosAlpha = cos(alpha),\n      sinAlpha = sin(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform(x, y) {\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform.invert = function(x, y) {\n    return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n  };\n  return transform;\n}\n\nexport default function projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nexport function projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n      alpha = 0, // post-rotate\n      theta = null, preclip = clipAntimeridian, // pre-clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n      delta2 = 0.5, // precision\n      projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * radians, point[1] * radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function(_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  projection.fitWidth = function(width, object) {\n    return fitWidth(projection, width, object);\n  };\n\n  projection.fitHeight = function(height, object) {\n    return fitHeight(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),\n        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose(project, transform);\n    projectRotateTransform = compose(rotate, projectTransform);\n    projectResample = resample(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n","import {asin, atan2, cos, sin, sqrt} from \"../math\";\n\nexport function azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nexport function azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n","import {asin, sqrt} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nexport default function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n","import {acos, sin} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nexport default function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n","import {atan, exp, halfPi, log, pi, tan, tau} from \"../math\";\nimport rotation from \"../rotation\";\nimport projection from \"./index\";\n\nexport function mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nexport default function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nexport function mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n","import projection from \"./index\";\n\nexport function equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nexport default function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n","import {abs, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {equirectangularRaw} from \"./equirectangular\";\n\nexport function conicEquidistantRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin(nx), g - gy * cos(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n}\n","import projection from \"./index.js\";\nimport {abs, asin, cos, epsilon2, sin, sqrt} from \"../math.js\";\n\nvar A1 = 1.340264,\n    A2 = -0.081106,\n    A3 = 0.000893,\n    A4 = 0.003796,\n    M = sqrt(3) / 2,\n    iterations = 12;\n\nexport function equalEarthRaw(lambda, phi) {\n  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\n\nequalEarthRaw.invert = function(x, y) {\n  var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs(delta) < epsilon2) break;\n  }\n  return [\n    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n    asin(sin(l) / M)\n  ];\n};\n\nexport default function() {\n  return projection(equalEarthRaw)\n      .scale(177.158);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nexport default function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n","import projection from \"./index\";\nimport {abs, epsilon} from \"../math\";\n\nexport function naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nexport default function() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n","import {asin, cos, epsilon, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nexport default function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nexport default function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n","import {atan, exp, halfPi, log, tan} from \"../math\";\nimport {mercatorProjection} from \"./mercator\";\n\nexport function transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nexport default function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n"],"sourceRoot":""}