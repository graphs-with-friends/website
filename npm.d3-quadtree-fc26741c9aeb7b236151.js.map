{"version":3,"sources":["webpack:///./node_modules/d3-quadtree/src/add.js","webpack:///./node_modules/d3-quadtree/src/cover.js","webpack:///./node_modules/d3-quadtree/src/quad.js","webpack:///./node_modules/d3-quadtree/src/x.js","webpack:///./node_modules/d3-quadtree/src/y.js","webpack:///./node_modules/d3-quadtree/src/quadtree.js","webpack:///./node_modules/d3-quadtree/src/data.js","webpack:///./node_modules/d3-quadtree/src/extent.js","webpack:///./node_modules/d3-quadtree/src/find.js","webpack:///./node_modules/d3-quadtree/src/remove.js","webpack:///./node_modules/d3-quadtree/src/root.js","webpack:///./node_modules/d3-quadtree/src/size.js","webpack:///./node_modules/d3-quadtree/src/visit.js","webpack:///./node_modules/d3-quadtree/src/visitAfter.js","webpack:///./node_modules/d3-quadtree/src/index.js"],"names":["add_add","tree","x","y","d","isNaN","parent","xm","ym","xp","yp","right","bottom","i","j","node","_root","leaf","data","x0","_x0","y0","_y0","x1","_x1","y1","_y1","length","_x","call","_y","next","Array","quad","this","defaultX","defaultY","quadtree","nodes","Quadtree","NaN","addAll","undefined","leaf_copy","copy","treeProto","prototype","child","source","target","pop","push","add","cover","n","xz","yz","Infinity","Math","floor","z","visit","extent","_","arguments","find","radius","x2","y2","q","x3","y3","quads","dx","dy","d2","sqrt","remove","retainer","previous","removeAll","root","size","callback","visitAfter","__webpack_require__","__webpack_exports__"],"mappings":"0FAMA,SAASA,QAAGC,EAAAC,EAAAC,EAAAC,GACZ,GAAAC,MAAAH,IAAAG,MAAAF,GAAA,OAAAF,EAEA,IAAAK,EAOAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAbAC,EAAAd,EAAAe,MACAC,EAAA,CAAcC,KAAAd,GACde,EAAAlB,EAAAmB,IACAC,EAAApB,EAAAqB,IACAC,EAAAtB,EAAAuB,IACAC,EAAAxB,EAAAyB,IAWA,IAAAX,EAAA,OAAAd,EAAAe,MAAAC,EAAAhB,EAGA,KAAAc,EAAAY,QAGA,IAFAhB,EAAAT,IAAAK,GAAAY,EAAAI,GAAA,IAAAJ,EAAAZ,EAAmDgB,EAAAhB,GACnDK,EAAAT,IAAAK,GAAAa,EAAAI,GAAA,IAAAJ,EAAAb,EAAoDiB,EAAAjB,EACpDF,EAAAS,QAAAF,EAAAD,GAAA,EAAAD,IAAA,OAAAL,EAAAO,GAAAI,EAAAhB,EAMA,GAFAQ,GAAAR,EAAA2B,GAAAC,KAAA,KAAAd,EAAAG,MACAR,GAAAT,EAAA6B,GAAAD,KAAA,KAAAd,EAAAG,MACAhB,IAAAO,GAAAN,IAAAO,EAAA,OAAAO,EAAAc,KAAAhB,EAAAT,IAAAO,GAAAI,EAAAhB,EAAAe,MAAAC,EAAAhB,EAGA,GACAK,MAAAO,GAAA,IAAAmB,MAAA,GAAA/B,EAAAe,MAAA,IAAAgB,MAAA,IACArB,EAAAT,IAAAK,GAAAY,EAAAI,GAAA,IAAAJ,EAAAZ,EAAmDgB,EAAAhB,GACnDK,EAAAT,IAAAK,GAAAa,EAAAI,GAAA,IAAAJ,EAAAb,EAAoDiB,EAAAjB,SACjDK,EAAAD,GAAA,EAAAD,KAAAG,GAAAJ,GAAAF,IAAA,EAAAC,GAAAF,IACH,OAAAD,EAAAQ,GAAAC,EAAAT,EAAAO,GAAAI,EAAAhB,EC9Ce,ICAAgC,EAAA,SAAAlB,EAAAI,EAAAE,EAAAE,EAAAE,GACfS,KAAAnB,OACAmB,KAAAf,KACAe,KAAAb,KACAa,KAAAX,KACAW,KAAAT,MCLO,SAAAU,SAAA/B,GACP,OAAAA,EAAA,GCDO,SAAAgC,SAAAhC,GACP,OAAAA,EAAA,GCYe,SAAAiC,SAAAC,EAAApC,EAAAC,GACf,IAAAF,EAAA,IAAAsC,SAAA,MAAArC,EAAsCiC,SAAQjC,EAAA,MAAAC,EAAkBiC,SAAQjC,EAAAqC,iBACxE,aAAAF,EAAArC,IAAAwC,OAAAH,GAGA,SAAAC,SAAArC,EAAAC,EAAAgB,EAAAE,EAAAE,EAAAE,GACAS,KAAAN,GAAA1B,EACAgC,KAAAJ,GAAA3B,EACA+B,KAAAd,IAAAD,EACAe,KAAAZ,IAAAD,EACAa,KAAAV,IAAAD,EACAW,KAAAR,IAAAD,EACAS,KAAAlB,WAAA0B,EAGA,SAAAC,UAAA1B,GAEA,IADA,IAAA2B,EAAA,CAAc1B,KAAAD,EAAAC,MAAgBa,EAAAa,EAC9B3B,IAAAc,eAAA,CAA+Cb,KAAAD,EAAAC,MAC/C,OAAA0B,EAGA,IAAAC,EAAAR,SAAAS,UAAAP,SAAAO,UAEAD,EAAAD,KAAA,WACA,IAEAN,EACAS,EAHAH,EAAA,IAAAL,SAAAL,KAAAN,GAAAM,KAAAJ,GAAAI,KAAAd,IAAAc,KAAAZ,IAAAY,KAAAV,IAAAU,KAAAR,KACAX,EAAAmB,KAAAlB,MAIA,IAAAD,EAAA,OAAA6B,EAEA,IAAA7B,EAAAY,OAAA,OAAAiB,EAAA5B,MAAA2B,UAAA5B,GAAA6B,EAGA,IADAN,EAAA,EAAYU,OAAAjC,EAAAkC,OAAAL,EAAA5B,MAAA,IAAAgB,MAAA,KACZjB,EAAAuB,EAAAY,OACA,QAAArC,EAAA,EAAmBA,EAAA,IAAOA,GAC1BkC,EAAAhC,EAAAiC,OAAAnC,MACAkC,EAAApB,OAAAW,EAAAa,KAAA,CAAsCH,OAAAD,EAAAE,OAAAlC,EAAAkC,OAAApC,GAAA,IAAAmB,MAAA,KACtCjB,EAAAkC,OAAApC,GAAA8B,UAAAI,IAKA,OAAAH,GAGAC,EAAAO,IL3De,SAAAhD,GACf,IAAAF,GAAAgC,KAAAN,GAAAC,KAAA,KAAAzB,GACAD,GAAA+B,KAAAJ,GAAAD,KAAA,KAAAzB,GACA,OAASJ,QAAGkC,KAAAmB,MAAAnD,EAAAC,GAAAD,EAAAC,EAAAC,IKyDZyC,EAAAJ,OLXO,SAAAA,OAAAvB,GACP,IAAAd,EAAAS,EACAX,EACAC,EAFAmD,EAAApC,EAAAS,OAGA4B,EAAA,IAAAvB,MAAAsB,GACAE,EAAA,IAAAxB,MAAAsB,GACAnC,EAAAsC,IACApC,EAAAoC,IACAlC,GAAA,IACAE,GAAA,IAGA,IAAAZ,EAAA,EAAaA,EAAAyC,IAAOzC,EACpBR,MAAAH,GAAAgC,KAAAN,GAAAC,KAAA,KAAAzB,EAAAc,EAAAL,MAAAR,MAAAF,GAAA+B,KAAAJ,GAAAD,KAAA,KAAAzB,MACAmD,EAAA1C,GAAAX,EACAsD,EAAA3C,GAAAV,EACAD,EAAAiB,MAAAjB,GACAA,EAAAqB,MAAArB,GACAC,EAAAkB,MAAAlB,GACAA,EAAAsB,MAAAtB,IAIA,GAAAgB,EAAAI,GAAAF,EAAAI,EAAA,OAAAS,KAMA,IAHAA,KAAAmB,MAAAlC,EAAAE,GAAAgC,MAAA9B,EAAAE,GAGAZ,EAAA,EAAaA,EAAAyC,IAAOzC,EAChBb,QAAGkC,KAAAqB,EAAA1C,GAAA2C,EAAA3C,GAAAK,EAAAL,IAGP,OAAAqB,MKrBAW,EAAAQ,MJ7De,SAAAnD,EAAAC,GACf,GAAAE,MAAAH,OAAAG,MAAAF,MAAA,OAAA+B,KAEA,IAAAf,EAAAe,KAAAd,IACAC,EAAAa,KAAAZ,IACAC,EAAAW,KAAAV,IACAC,EAAAS,KAAAR,IAKA,GAAArB,MAAAc,GACAI,GAAAJ,EAAAuC,KAAAC,MAAAzD,IAAA,EACAuB,GAAAJ,EAAAqC,KAAAC,MAAAxD,IAAA,MAIA,CAMA,IALA,IAEAG,EACAO,EAHA+C,EAAArC,EAAAJ,EACAJ,EAAAmB,KAAAlB,MAIAG,EAAAjB,MAAAqB,GAAAF,EAAAlB,MAAAsB,GAGA,OAFAZ,GAAAV,EAAAkB,IAAA,EAAAnB,EAAAiB,GACAb,EAAA,IAAA0B,MAAA,IAAAnB,GAAAE,IAAAT,EAAAsD,GAAA,EACA/C,GACA,OAAAU,EAAAJ,EAAAyC,EAAAnC,EAAAJ,EAAAuC,EAAyC,MACzC,OAAAzC,EAAAI,EAAAqC,EAAAnC,EAAAJ,EAAAuC,EAAyC,MACzC,OAAArC,EAAAJ,EAAAyC,EAAAvC,EAAAI,EAAAmC,EAAyC,MACzC,OAAAzC,EAAAI,EAAAqC,EAAAvC,EAAAI,EAAAmC,EAIA1B,KAAAlB,OAAAkB,KAAAlB,MAAAW,SAAAO,KAAAlB,MAAAD,GAOA,OAJAmB,KAAAd,IAAAD,EACAe,KAAAZ,IAAAD,EACAa,KAAAV,IAAAD,EACAW,KAAAR,IAAAD,EACAS,MIqBAW,EAAA3B,KC9De,WACf,IAAAA,EAAA,GAIA,OAHAgB,KAAA2B,MAAA,SAAA9C,GACA,IAAAA,EAAAY,OAAA,GAAAT,EAAAiC,KAAApC,EAAAG,YAA8CH,IAAAgB,QAE9Cb,GD0DA2B,EAAAiB,OE/De,SAAAC,GACf,OAAAC,UAAArC,OACAO,KAAAmB,OAAAU,EAAA,OAAAA,EAAA,OAAAV,OAAAU,EAAA,OAAAA,EAAA,OACA1D,MAAA6B,KAAAd,UAAAsB,EAAA,EAAAR,KAAAd,IAAAc,KAAAZ,KAAA,CAAAY,KAAAV,IAAAU,KAAAR,OF6DAmB,EAAAoB,KG9De,SAAA/D,EAAAC,EAAA+D,GACf,IAAAhD,EAGAK,EACAE,EACA0C,EACAC,EAKAC,EACAxD,EAXAM,EAAAe,KAAAd,IACAC,EAAAa,KAAAZ,IAKAgD,EAAApC,KAAAV,IACA+C,EAAArC,KAAAR,IACA8C,EAAA,GACAzD,EAAAmB,KAAAlB,MAYA,IARAD,GAAAyD,EAAArB,KAAA,IAA2BlB,EAAIlB,EAAAI,EAAAE,EAAAiD,EAAAC,IAC/B,MAAAL,IAAAT,KAEAtC,EAAAjB,EAAAgE,EAAA7C,EAAAlB,EAAA+D,EACAI,EAAApE,EAAAgE,EAAAK,EAAApE,EAAA+D,EACAA,MAGAG,EAAAG,EAAAtB,OAGA,OAAAnC,EAAAsD,EAAAtD,QACAQ,EAAA8C,EAAAlD,IAAAmD,IACA7C,EAAA4C,EAAAhD,IAAAkD,IACAJ,EAAAE,EAAA9C,IAAAJ,IACAiD,EAAAC,EAAA5C,IAAAJ,GAGA,GAAAN,EAAAY,OAAA,CACA,IAAApB,GAAAgB,EAAA4C,GAAA,EACA3D,GAAAiB,EAAA2C,GAAA,EAEAI,EAAArB,KACA,IAAYlB,EAAIlB,EAAA,GAAAR,EAAAC,EAAA2D,EAAAC,GAChB,IAAYnC,EAAIlB,EAAA,GAAAQ,EAAAf,EAAAD,EAAA6D,GAChB,IAAYnC,EAAIlB,EAAA,GAAAR,EAAAkB,EAAA0C,EAAA3D,GAChB,IAAYyB,EAAIlB,EAAA,GAAAQ,EAAAE,EAAAlB,EAAAC,KAIhBK,GAAAV,GAAAK,IAAA,EAAAN,GAAAK,KACA8D,EAAAG,IAAA7C,OAAA,GACA6C,IAAA7C,OAAA,GAAA6C,IAAA7C,OAAA,EAAAd,GACA2D,IAAA7C,OAAA,EAAAd,GAAAwD,OAKA,CACA,IAAAI,EAAAvE,GAAAgC,KAAAN,GAAAC,KAAA,KAAAd,EAAAG,MACAwD,EAAAvE,GAAA+B,KAAAJ,GAAAD,KAAA,KAAAd,EAAAG,MACAyD,EAAAF,IAAAC,IACA,GAAAC,EAAAT,EAAA,CACA,IAAA9D,EAAAsD,KAAAkB,KAAAV,EAAAS,GACAxD,EAAAjB,EAAAE,EAAAiB,EAAAlB,EAAAC,EACAkE,EAAApE,EAAAE,EAAAmE,EAAApE,EAAAC,EACAc,EAAAH,EAAAG,MAKA,OAAAA,GHHA2B,EAAAgC,OIjEe,SAAAzE,GACf,GAAAC,MAAAH,GAAAgC,KAAAN,GAAAC,KAAA,KAAAzB,KAAAC,MAAAF,GAAA+B,KAAAJ,GAAAD,KAAA,KAAAzB,IAAA,OAAA8B,KAEA,IAAA5B,EAEAwE,EACAC,EACAhD,EAKA7B,EACAC,EACAI,EACAC,EACAG,EACAC,EACAC,EACAC,EAfAC,EAAAmB,KAAAlB,MAIAG,EAAAe,KAAAd,IACAC,EAAAa,KAAAZ,IACAC,EAAAW,KAAAV,IACAC,EAAAS,KAAAR,IAWA,IAAAX,EAAA,OAAAmB,KAIA,GAAAnB,EAAAY,OAAA,QAGA,IAFAhB,EAAAT,IAAAK,GAAAY,EAAAI,GAAA,IAAAJ,EAAAZ,EAAmDgB,EAAAhB,GACnDK,EAAAT,IAAAK,GAAAa,EAAAI,GAAA,IAAAJ,EAAAb,EAAoDiB,EAAAjB,EACpDF,EAAAS,QAAAF,EAAAD,GAAA,EAAAD,IAAA,OAAAuB,KACA,IAAAnB,EAAAY,OAAA,OACArB,EAAAO,EAAA,MAAAP,EAAAO,EAAA,MAAAP,EAAAO,EAAA,QAAAiE,EAAAxE,EAAAQ,EAAAD,GAIA,KAAAE,EAAAG,OAAAd,GAAA,GAAA2E,EAAAhE,QAAAgB,MAAA,OAAAG,KAIA,OAHAH,EAAAhB,EAAAgB,cAAAhB,EAAAgB,KAGAgD,GAAAhD,EAAAgD,EAAAhD,cAAAgD,EAAAhD,KAAAG,MAGA5B,GAGAyB,EAAAzB,EAAAO,GAAAkB,SAAAzB,EAAAO,IAGAE,EAAAT,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,KACAS,KAAAT,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,MACAS,EAAAY,SACAmD,IAAAhE,GAAAC,EACAmB,KAAAlB,MAAAD,GAGAmB,OAbAA,KAAAlB,MAAAe,EAAAG,OJwBAW,EAAAmC,UIRO,SAAAA,UAAA9D,GACP,QAAAL,EAAA,EAAAyC,EAAApC,EAAAS,OAAkCd,EAAAyC,IAAOzC,EAAAqB,KAAA2C,OAAA3D,EAAAL,IACzC,OAAAqB,MJOAW,EAAAoC,KKnEe,WACf,OAAA/C,KAAAlB,OLmEA6B,EAAAqC,KMpEe,WACf,IAAAA,EAAA,EAIA,OAHAhD,KAAA2B,MAAA,SAAA9C,GACA,IAAAA,EAAAY,OAAA,KAAAuD,QAAgCnE,IAAAgB,QAEhCmD,GNgEArC,EAAAgB,MOnEe,SAAAsB,GACf,IAAAd,EAAAtB,EAAA5B,EAAAE,EAAAE,EAAAE,EAAA+C,EAAA,GAAAzD,EAAAmB,KAAAlB,MAEA,IADAD,GAAAyD,EAAArB,KAAA,IAA2BlB,EAAIlB,EAAAmB,KAAAd,IAAAc,KAAAZ,IAAAY,KAAAV,IAAAU,KAAAR,MAC/B2C,EAAAG,EAAAtB,OACA,IAAAiC,EAAApE,EAAAsD,EAAAtD,KAAAI,EAAAkD,EAAAlD,GAAAE,EAAAgD,EAAAhD,GAAAE,EAAA8C,EAAA9C,GAAAE,EAAA4C,EAAA5C,KAAAV,EAAAY,OAAA,CACA,IAAApB,GAAAY,EAAAI,GAAA,EAAAf,GAAAa,EAAAI,GAAA,GACAsB,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAAxC,EAAAC,EAAAe,EAAAE,KAC9CsB,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAA5B,EAAAX,EAAAD,EAAAkB,KAC9CsB,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAAxC,EAAAc,EAAAE,EAAAf,KAC9CuC,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAA5B,EAAAE,EAAAd,EAAAC,IAG9C,OAAA0B,MPwDAW,EAAAuC,WQpEe,SAAAD,GACf,IAAAd,EAAAG,EAAA,GAAAzC,EAAA,GAEA,IADAG,KAAAlB,OAAAwD,EAAArB,KAAA,IAAiClB,EAAIC,KAAAlB,MAAAkB,KAAAd,IAAAc,KAAAZ,IAAAY,KAAAV,IAAAU,KAAAR,MACrC2C,EAAAG,EAAAtB,OAAA,CACA,IAAAnC,EAAAsD,EAAAtD,KACA,GAAAA,EAAAY,OAAA,CACA,IAAAoB,EAAA5B,EAAAkD,EAAAlD,GAAAE,EAAAgD,EAAAhD,GAAAE,EAAA8C,EAAA9C,GAAAE,EAAA4C,EAAA5C,GAAAlB,GAAAY,EAAAI,GAAA,EAAAf,GAAAa,EAAAI,GAAA,GACAsB,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAA5B,EAAAE,EAAAd,EAAAC,KAC9CuC,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAAxC,EAAAc,EAAAE,EAAAf,KAC9CuC,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAA5B,EAAAX,EAAAD,EAAAkB,KAC9CsB,EAAAhC,EAAA,KAAAyD,EAAArB,KAAA,IAA0ClB,EAAIc,EAAAxC,EAAAC,EAAAe,EAAAE,IAE9CM,EAAAoB,KAAAkB,GAEA,KAAAA,EAAAtC,EAAAmB,OACAiC,EAAAd,EAAAtD,KAAAsD,EAAAlD,GAAAkD,EAAAhD,GAAAgD,EAAA9C,GAAA8C,EAAA5C,IAEA,OAAAS,MRoDAW,EAAA3C,EFnEe,SAAA6D,GACf,OAAAC,UAAArC,QAAAO,KAAAN,GAAAmC,EAAA7B,WAAAN,IEmEAiB,EAAA1C,EDpEe,SAAA4D,GACf,OAAAC,UAAArC,QAAAO,KAAAJ,GAAAiC,EAAA7B,WAAAJ,IULAuD,EAAAjF,EAAAkF,EAAA,sBAAAjD","file":"npm.d3-quadtree-fc26741c9aeb7b236151.js","sourcesContent":["export default function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n}\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, abort.\n  if (x0 > x1 || y0 > y1) return this;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n","export default function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    while (x0 > x || x >= x1 || y0 > y || y >= y1) {\n      i = (y < y0) << 1 | (x < x0);\n      parent = new Array(4), parent[i] = node, node = parent, z *= 2;\n      switch (i) {\n        case 0: x1 = x0 + z, y1 = y0 + z; break;\n        case 1: x0 = x1 - z, y1 = y0 + z; break;\n        case 2: x1 = x0 + z, y0 = y1 - z; break;\n        case 3: x0 = x1 - z, y0 = y1 - z; break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}\n","export default function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n}\n","export function defaultX(d) {\n  return d[0];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n","export function defaultY(d) {\n  return d[1];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n","import tree_add, {addAll as tree_addAll} from \"./add\";\nimport tree_cover from \"./cover\";\nimport tree_data from \"./data\";\nimport tree_extent from \"./extent\";\nimport tree_find from \"./find\";\nimport tree_remove, {removeAll as tree_removeAll} from \"./remove\";\nimport tree_root from \"./root\";\nimport tree_size from \"./size\";\nimport tree_visit from \"./visit\";\nimport tree_visitAfter from \"./visitAfter\";\nimport tree_x, {defaultX} from \"./x\";\nimport tree_y, {defaultY} from \"./y\";\n\nexport default function quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = tree_addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = tree_removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n","export default function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n}\n","export default function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n","import Quad from \"./quad\";\n\nexport default function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant can’t contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n}\n","export default function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n}\n\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n","export default function() {\n  return this._root;\n}\n","export default function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n}\n","import Quad from \"./quad\";\n\nexport default function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n}\n","import Quad from \"./quad\";\n\nexport default function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n","export {default as quadtree} from \"./quadtree\";\n"],"sourceRoot":""}