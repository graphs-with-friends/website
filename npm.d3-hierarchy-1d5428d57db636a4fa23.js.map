{"version":3,"sources":["webpack:///./node_modules/d3-hierarchy/src/hierarchy/count.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/index.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/each.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sum.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sort.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/path.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/ancestors.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/descendants.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/leaves.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/links.js","webpack:///./node_modules/d3-hierarchy/src/array.js","webpack:///./node_modules/d3-hierarchy/src/treemap/round.js","webpack:///./node_modules/d3-hierarchy/src/treemap/dice.js","webpack:///./node_modules/d3-hierarchy/src/tree.js","webpack:///./node_modules/d3-hierarchy/src/treemap/slice.js","webpack:///./node_modules/d3-hierarchy/src/treemap/squarify.js","webpack:///./node_modules/d3-hierarchy/src/treemap/resquarify.js"],"names":["count","node","sum","children","i","length","value","hierarchy","data","child","childs","n","root","Node","valued","nodes","defaultChildren","pop","Array","push","parent","depth","eachBefore","computeHeight","d","copyData","height","this","prototype","constructor","eachAfter","each","callback","current","next","reverse","sort","compare","path","end","start","ancestor","leastCommonAncestor","a","b","aNodes","ancestors","bNodes","c","k","splice","descendants","leaves","links","source","target","copy","node_copy","slice","dice","x0","y0","x1","y1","TreeNode","_","A","z","m","s","t","Object","create","treemap_slice","phi","Math","sqrt","squarifyRatio","ratio","row","nodeValue","dx","dy","sumValue","minValue","maxValue","newRatio","minRatio","alpha","beta","rows","i0","i1","max","custom","squarify","x","resquarify","_squarify","j"],"mappings":"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","file":"npm.d3-hierarchy-1d5428d57db636a4fa23.js","sourcesContent":["function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n","import node_count from \"./count\";\nimport node_each from \"./each\";\nimport node_eachBefore from \"./eachBefore\";\nimport node_eachAfter from \"./eachAfter\";\nimport node_sum from \"./sum\";\nimport node_sort from \"./sort\";\nimport node_path from \"./path\";\nimport node_ancestors from \"./ancestors\";\nimport node_descendants from \"./descendants\";\nimport node_leaves from \"./leaves\";\nimport node_links from \"./links\";\n\nexport default function hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n","export default function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n","export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n","export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n","export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n","export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n","export default function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n","export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n","export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n","export var slice = Array.prototype.slice;\n\nexport function shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n","export default function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n","import {Node} from \"./hierarchy/index\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\nimport {phi, squarifyRatio} from \"./squarify\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n"],"sourceRoot":""}