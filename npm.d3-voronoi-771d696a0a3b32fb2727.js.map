{"version":3,"sources":["webpack:///./node_modules/d3-voronoi/src/RedBlackTree.js","webpack:///./node_modules/d3-voronoi/src/Edge.js","webpack:///./node_modules/d3-voronoi/src/Cell.js","webpack:///./node_modules/d3-voronoi/src/Circle.js","webpack:///./node_modules/d3-voronoi/src/Beach.js","webpack:///./node_modules/d3-voronoi/src/Diagram.js"],"names":["RedBlackTree","this","_","RedBlackNode","node","U","C","L","R","P","N","RedBlackRotateLeft","tree","p","q","parent","RedBlackRotateRight","RedBlackFirst","prototype","constructor","insert","after","grandpa","uncle","remove","sibling","next","red","left","right","src_RedBlackTree","createEdge","v0","v1","edge","index","Diagram_edges","push","setEdgeEnd","cells","halfedges","createBorderEdge","vertex","clipEdge","x0","y0","x1","y1","r","a","b","ax","ay","t0","t1","dx","dy","connectEdge","fm","fb","lx","ly","rx","ry","fx","fy","cellHalfedgeAngle","cell","site","va","vb","Math","atan2","cellHalfedgeStart","cellHalfedgeEnd","firstCircle","circlePool","Circle","x","y","arc","cy","attachCircle","lArc","rArc","lSite","cSite","rSite","bx","by","cx","d","epsilon2","ha","hc","circle","pop","sqrt","before","circles","detachCircle","beachPool","Beach","createBeach","beach","detachBeach","beaches","removeBeach","previous","disappearing","abs","epsilon","unshift","iArc","nArcs","length","addBeach","dxl","dxr","directrix","leftBreakPoint","rightBreakPoint","createCell","newArc","hb","rfocx","rfocy","pby2","Infinity","lfocx","lfocy","plby2","hl","aby2","lexicographic","Diagram","sites","extent","sort","Array","sortCellHalfedges","j","m","i","n","array","clipEdges","clipCells","iCell","iHalfedge","nHalfedges","start","startX","startY","end","endX","endY","nCells","cover","splice","d2","dc","v00","v01","v11","v10","edges","polygons","map","polygon","data","triangles","forEach","s0","c","e1","s1","links","filter","source","target","find","radius","i0","that","i1","_found","e","v","vx","vy","v2"],"mappings":"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","file":"npm.d3-voronoi-771d696a0a3b32fb2727.js","sourcesContent":["function RedBlackTree() {\n  this._ = null; // root node\n}\n\nexport function RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\nexport default RedBlackTree;\n","import {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nexport function createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nexport function setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// Liang–Barsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nexport function clipEdges(x0, y0, x1, y1) {\n  var i = edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {\n      delete edges[i];\n    }\n  }\n}\n","import {createBorderEdge} from \"./Edge\";\nimport {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n","import {RedBlackNode} from \"./RedBlackTree\";\nimport {circles, epsilon2} from \"./Diagram\";\n\nvar circlePool = [];\n\nexport var firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nexport function attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nexport function detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n","import {RedBlackNode} from \"./RedBlackTree\";\nimport {createCell} from \"./Cell\";\nimport {attachCircle, detachCircle} from \"./Circle\";\nimport {createEdge, setEdgeEnd} from \"./Edge\";\nimport {beaches, epsilon} from \"./Diagram\";\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nexport function removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon\n      && Math.abs(y - lArc.circle.cy) < epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon\n      && Math.abs(y - rArc.circle.cy) < epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nexport function addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n","import {addBeach, removeBeach} from \"./Beach\";\nimport {sortCellHalfedges, cellHalfedgeStart, clipCells} from \"./Cell\";\nimport {firstCircle} from \"./Circle\";\nimport {clipEdges} from \"./Edge\";\nimport RedBlackTree from \"./RedBlackTree\";\n\nexport var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var beaches;\nexport var cells;\nexport var circles;\nexport var edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nexport default function Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n}\n"],"sourceRoot":""}